<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BADSEED // GOD MODE CONSOLE</title>
    <script src="https://unpkg.com/@solana/web3.js@1.98.0/lib/index.iife.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sha256/0.9.0/sha256.min.js"></script>
    <!-- Use Bundle.run to get a Browserified version of Buffer -->
    <script src="https://bundle.run/buffer@6.0.3"></script>
    <script>
        // Polyfill Buffer Global (Bundle.run exposes 'buffer' on window)
        window.Buffer = window.Buffer || window.buffer.Buffer;
        console.log("Buffer Loaded:", typeof window.Buffer);
    </script>
    <script>
        // --- WALLET STANDARD SUPPORT (EARLY BINDING) ---
        // Moved to HEAD to catch events that fire before BODY loads
        const standardAdapters = [];
        try {
            function onWalletRegistered(event) {
                const { register } = event.detail;
                register((adapter) => {
                    standardAdapters.push(adapter);
                    // Dispatch custom event to notify UI if needed
                    window.dispatchEvent(new Event('wallet-standard-updated'));
                });
            }
            window.addEventListener('register-wallet', onWalletRegistered);
        } catch (e) { console.error("Standard Wallet Init Error", e); }
    </script>
    <style>
        body {
            background-color: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            height: 95vh;
            overflow: hidden;
        }

        /* --- SCROLLBARS --- */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #001100;
            border-left: 1px solid #003300;
        }

        ::-webkit-scrollbar-thumb {
            background: #004400;
            border: 1px solid #0f0;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #0f0;
            box-shadow: 0 0 10px #0f0;
        }

        /* --- LAYOUT --- */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #0f0;
            padding-bottom: 15px;
            margin-bottom: 20px;
        }

        .title {
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 12px;
            opacity: 0.7;
            letter-spacing: 4px;
        }

        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 15px;
            flex: 1;
            overflow-y: auto;
            padding-bottom: 20px;
        }

        /* --- HEARTBEAT --- */
        .heartbeat {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            letter-spacing: 1px;
            border: 1px solid #111;
            padding: 5px 10px;
            background: #050505;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #333;
            box-shadow: 0 0 5px #333;
            transition: all 0.5s ease;
        }

        /* --- PANELS --- */
        .panel {
            border: 1px solid #004400;
            background: rgba(0, 10, 0, 0.8);
            padding: 15px;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px dashed #004400;
            padding-bottom: 8px;
            margin-bottom: 10px;
        }

        .panel h3 {
            margin: 0;
            font-size: 14px;
            color: #8f8;
            text-transform: uppercase;
        }

        /* --- DATA --- */
        .data-row {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-bottom: 6px;
            border-bottom: 1px solid #001100;
        }

        .label {
            color: #484;
        }

        .value {
            color: #cfc;
            font-weight: bold;
        }

        .highlight {
            color: #ff0;
            text-shadow: 0 0 5px #aa0;
        }

        .small-text {
            font-size: 10px;
            opacity: 0.7;
        }

        .divider {
            height: 1px;
            background: #003300;
            margin: 10px 0;
        }

        /* --- LISTS --- */
        .scroll-list {
            overflow-y: auto;
            flex: 1;
            font-size: 11px;
            scrollbar-width: thin;
            scrollbar-color: #004400 #000;
        }

        .list-item {
            padding: 4px 0;
            border-bottom: 1px solid #001100;
            color: #8c8;
        }

        /* --- CONTROLS --- */
        .controls {
            display: flex;
            gap: 5px;
        }

        button {
            background: #002200;
            color: #0f0;
            border: 1px solid #0f0;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            padding: 4px 8px;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
        }

        button:hover {
            background: #0f0;
            color: #000;
        }

        .btn-action {
            border-color: #0ff;
            color: #0ff;
        }

        .btn-action:hover {
            background: #0ff;
            color: #000;
        }

        .btn-danger {
            border-color: #f33;
            color: #f33;
        }

        .btn-danger:hover {
            background: #f00;
            color: #fff;
            box-shadow: 0 0 10px #f00;
        }

        /* --- SENTIMENT BARS & MINI CONTROLS --- */
        .bar-container {
            margin-bottom: 8px;
        }

        .bar-label {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #686;
            margin-bottom: 2px;
        }

        .bar-track {
            width: 100%;
            height: 6px;
            background: #000500;
            border: 1px solid #003300;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .control-panel-mini {
            margin-top: 15px;
            border-top: 1px dashed #333;
            padding-top: 10px;
        }

        .control-panel-mini h4 {
            margin: 0 0 5px 0;
            font-size: 10px;
            color: #555;
        }

        .inject-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            font-size: 10px;
            color: #aaa;
        }

        .btn-mini {
            padding: 1px 4px;
            font-size: 9px;
            min-width: 25px;
        }

        /* --- OVERRIDE TEXTAREA --- */
        #prophecy-override textarea {
            background: #050505;
            color: #0f0;
            border: 1px solid #0f0;
            width: 100%;
            box-sizing: border-box;
            font-family: 'Courier New';
            margin-top: 5px;
            padding: 5px;
            resize: vertical;
        }

        /* --- CODE BLOCK --- */
        .code-block {
            font-family: 'Consolas', monospace;
            font-size: 11px;
            background: #000500;
            color: #efe;
            border: 1px solid #002200;
            padding: 8px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* GLITCH EFFECT (Optional) */
        @keyframes flicker {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.8;
            }

            100% {
                opacity: 1;
            }
        }

        .status-dot.online {
            animation: flicker 2s infinite;
        }
    </style>
</head>

<body>
    <div class="header">
        <div class="header-left">
            <div class="title">BAD SEED // GOD MODE</div>
            <div class="subtitle">SYSTEM OVERWATCH & CONTROL // V2.0 (MODERN WALLETS)</div>
        </div>
        <div class="header-right" style="display:flex; gap:10px; align-items:center;">
            <button id="wallet-btn" onclick="openWalletSelector()" style="border-color:#0ff; color:#0ff;">CONNECT
                WALLET</button>
            <div class="heartbeat" id="heartbeat-display">
                <div class="status-dot" id="hb-dot"></div>
                <span id="hb-text">INITIALIZING...</span>
                <button id="hb-wake"
                    style="display:none; background:none; border:none; color:#f00; cursor:pointer; font-size:12px; padding:0 5px;"
                    onclick="wakePoller()" title="Force Pulse">‚ö°</button>
            </div>
        </div>
    </div>

    <div class="dashboard-grid">

        <!-- ROW 1: PROPHECY & SENTIMENT -->
        <div class="panel" style="grid-column: span 8;">
            <div class="panel-header">
                <h3>VOICE NODE (PROPHECY)</h3>
                <div class="controls">
                    <button class="btn btn-action" onclick="forceProphecy()">üîÆ FORCE (BLURRED)</button>
                    <button class="btn btn-action" style="background:#000; border-color:#fff; color:#fff;"
                        onclick="revealProphecy()">REVEAL</button>
                    <button class="btn btn-danger" onclick="toggleOverride()">OVERRIDE</button>
                    <button onclick="fetchVoice(true)">REFRESH</button>
                </div>
            </div>

            <div id="prophecy-display">
                <div class="data-row">
                    <span class="label">STATUS:</span>
                    <span class="value" id="prophecy-status">LOADING...</span>
                </div>
                <div class="code-block" id="prophecy-text" style="height:80px; overflow-y:auto;">Fetching from neural
                    net...</div>
            </div>

            <div id="prophecy-override"
                style="display: none; margin-top: 10px; border-top: 1px solid #333; padding-top: 10px;">
                <div style="font-size:10px; color:#f00; margin-bottom:5px;">WARNING: DIRECT DATABASE OVERWRITE</div>
                <textarea id="override-text" rows="3" placeholder="ENTER DIVINE WILL..."></textarea>
                <div style="display:flex; gap:5px; margin-top:5px;">
                    <button class="btn btn-danger" style="flex:1" onclick="submitOverride()">EXECUTE OVERWRITE</button>
                    <button onclick="toggleOverride()">CANCEL</button>
                </div>
            </div>

            <!-- LOGIC HELP MODAL -->
            <div id="logic-modal"
                style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:#001100; border:2px solid #0f0; padding:20px; z-index:1000; width:600px; max-height:80vh; overflow-y:auto; font-family:'Consolas',monospace;">
                <h3 style="margin-top:0; color:#0f0;">SENTIMENT LOGIC EXAMPLES</h3>
                <div style="font-size:11px; color:#ccc; margin-bottom:10px;">
                    The logic engine maps transaction params to emotional shifts.
                    Rules are evaluated top-to-bottom. First match wins (unless 'stop':false is used? No, usually
                    accumulative or first match).
                    Actually, the current engine sums ALL matches.
                </div>

                <h4 style="color:#0ff; margin-bottom:5px;">1. SIMPLE KEYWORD MATCH</h4>
                <div class="code-block" style="margin-bottom:10px;">
                    {
                    "condition": { "memo": "love" },
                    "effect": { "hope": 2 },
                    "description": "Any memo containing 'love' adds +2 Hope"
                    }</div>

                <h4 style="color:#0f0; margin-bottom:5px;">2. HIGH VALUE TRANSACTION</h4>
                <div class="code-block" style="margin-bottom:10px;">
                    {
                    "condition": { "amount_gt": 1.0 },
                    "effect": { "greed": 5, "fear": -1 },
                    "description": "Transfers > 1.0 SOL boost Greed massive"
                    }</div>

                <h4 style="color:#f00; margin-bottom:5px;">3. COMPLEX REGEX (Start/End)</h4>
                <div class="code-block" style="margin-bottom:10px;">
                    {
                    "condition": { "memo_regex": "^(burn|die|kill)$" },
                    "effect": { "fear": 3 },
                    "description": "Exact match for burn, die, or kill"
                    }</div>

                <div style="font-size:10px; color:#666;">
                    <strong>Available Conditions:</strong> memo (includes), memo_regex, amount_gt, amount_lt, sender
                    (address).<br>
                    <strong>Available Effects:</strong> hope, greed, fear, mystery (integers).
                </div>

                <button onclick="document.getElementById('logic-modal').style.display='none'"
                    style="margin-top:15px; width:100%;">CLOSE HELP</button>
            </div>


        </div>

        <div class="panel" style="grid-column: span 4;">
            <div class="panel-header">
                <h3>COLLECTIVE PSYCHE</h3>
                <div class="timestamp" id="sentiment-time">--:--</div>
            </div>

            <div class="sentiment-bars" id="sentiment-bars" style="margin-top:5px;">
                <!-- Bars injected by JS -->
                <div style="font-size:10px; color:#666;">Loading Psychology...</div>
            </div>

            <div class="control-panel-mini">
                <h4>EMOTION INJECTION</h4>
                <div class="inject-row">
                    <span style="color:#0ff">HOPE</span>
                    <div>
                        <button class="btn-mini" onclick="injectEmotion('hope', -1)">-1</button>
                        <button class="btn-mini btn-action" onclick="injectEmotion('hope', 1)">+1</button>
                        <button class="btn-mini btn-action" onclick="injectEmotion('hope', 2)">+2</button>
                    </div>
                </div>
                <div class="inject-row">
                    <span style="color:#0f0">GREED</span>
                    <div>
                        <button class="btn-mini" onclick="injectEmotion('greed', -1)">-1</button>
                        <button class="btn-mini btn-action" onclick="injectEmotion('greed', 1)">+1</button>
                        <button class="btn-mini btn-action" onclick="injectEmotion('greed', 2)">+2</button>
                    </div>
                </div>
                <div class="inject-row">
                    <span style="color:#f00">FEAR</span>
                    <div>
                        <button class="btn-mini" onclick="injectEmotion('fear', -1)">-1</button>
                        <button class="btn-mini btn-action" onclick="injectEmotion('fear', 1)">+1</button>
                        <button class="btn-mini btn-action" onclick="injectEmotion('fear', 2)">+2</button>
                    </div>
                </div>
                <div class="inject-row">
                    <span style="color:#90f">MYSTERY</span>
                    <div>
                        <button class="btn-mini" onclick="injectEmotion('mystery', -1)">-1</button>
                        <button class="btn-mini btn-action" onclick="injectEmotion('mystery', 1)">+1</button>
                        <button class="btn-mini btn-action" onclick="injectEmotion('mystery', 2)">+2</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- ROW 2: WALLET & ARCHIVE -->
        <div class="panel" style="grid-column: span 6;">
            <div class="panel-header">
                <h3>TREASURY</h3>
                <div class="timestamp" id="wallet-time" style="font-size:10px; color:#666;">--:--</div>
            </div>
            <div class="data-row">
                <span class="label">ADDRESS:</span>
                <span class="value small-text">9TyzcephhXEw67piYNc72EJtgVmbq3AZhyPFSvdfXWdr</span>
            </div>
            <div class="data-row">
                <span class="label">BALANCE:</span>
                <span class="value highlight" id="wallet-balance">...</span>
            </div>
            <div class="divider"></div>
            <h4 style="margin:0 0 5px 0; font-size:10px; color:#666;">RECENT TRANSACTIONS</h4>
            <div id="wallet-txs" class="scroll-list" style="height: 100px;">
                <div class="list-item">Loading chain data...</div>
            </div>
        </div>

        <div class="panel" style="grid-column: span 6;">
            <div class="panel-header">
                <h3>PERMANENT ARCHIVE</h3>
                <button class="btn btn-action" onclick="forceArchive()">FORCE SAVE</button>
            </div>
            <div class="data-row">
                <span class="label">LAST SNAPSHOT:</span>
                <span class="value" id="archive-last">...</span>
            </div>
            <div class="data-row">
                <span class="label">PENDING UPLOADS:</span>
                <span class="value" id="archive-pending">...</span>
            </div>
            <div class="data-row">
                <span class="label">TOTAL HISTORY:</span>
                <span class="value" id="archive-total">...</span>
            </div>
            <div class="divider"></div>
            <h4 style="margin:0 0 5px 0; font-size:10px; color:#666;">ARCHIVE LOGS</h4>
            <div id="archive-log" class="scroll-list" style="height: 80px;">
                <div class="list-item">Syncing...</div>
            </div>
        </div>

        <!-- ROW 3: X.COM QUEUE -->
        <div class="panel" style="grid-column: span 12;">
            <div class="panel-header">
                <h3>NEURAL QUEUE (AI MEMORY)</h3>
                <div class="controls" style="display:flex; align-items:center; gap:10px;">
                    <span id="queue-timer" style="font-size:10px; color:#aaa;">NEXT POST: --:--:--</span>
                    <button onclick="forcePost()" style="color:#0ff; border-color:#0ff;">‚ö° FORCE POST</button>
                    <button onclick="addTestItem()">üß™ ADD TEST</button>
                    <button id="btn-pause" onclick="togglePauseQueue()" style="min-width:60px;">...</button>
                    <button onclick="clearQueue()" class="btn-danger">üóëÔ∏è CLEAR</button>
                    <button onclick="fetchQueue()">REFRESH</button>
                </div>
            </div>
            <div id="queue-list" class="scroll-list" style="height: 150px;">
                <!-- Full Narratives go here -->
                <div class="list-item">Scanning neural queue...</div>
            </div>
        </div>

        <!-- ROW 4: ADMIN LOGIC & ACTIONS -->
        <div class="panel" style="grid-column: span 8;">
            <div class="panel-header">
                <h3>ADMIN: SENTIMENT LOGIC</h3>
                <div class="controls">
                    <button onclick="document.getElementById('logic-modal').style.display='block'"
                        style="color:#0ff; border-color:#0ff;">?</button>
                    <button onclick="fetchLogic()" class="btn-action">LOAD RULES</button>
                    <button onclick="saveLogic()" class="btn-danger">SAVE CHANGES</button>
                </div>
            </div>
            <div style="font-size:10px; color:#666; margin-bottom:5px;">Configure how transactions map to emotions.
                format: JSON</div>
            <textarea id="logic-editor"
                style="width:100%; height:120px; background:#000; color:#0f0; border:1px solid #333; font-family:'Consolas','Courier New'; font-size:11px; padding:5px;">// Loading rules...</textarea>
        </div>

        <div class="panel" style="grid-column: span 4;">
            <div class="panel-header">
                <h3>GOD ACTIONS</h3>
                <span id="wallet-status" style="font-size:10px; color:#666;">NO WALLET</span>
            </div>

            <div style="display:flex; flex-direction:column; gap:10px; margin-top:10px;">
                <button class="btn btn-action" onclick="openSacrifice()" style="padding:10px;">üíÄ SACRIFICE
                    (BURN)</button>
                <button class="btn btn-action" onclick="openMessage()" style="padding:10px;">üí¨ SEND MESSAGE</button>
            </div>

            <!-- HIDDEN MODALS (Simple divs for now) -->
            <div id="action-ui" style="margin-top:15px; border-top:1px dashed #333; padding-top:10px; display:none;">
                <h4 id="action-title" style="margin:0 0 5px 0;">ACTION</h4>
                <input id="action-input-1" placeholder="Amount / Memo"
                    style="width:100%; background:#000; border:1px solid #333; color:#fff; margin-bottom:5px;">
                <input id="action-input-2" placeholder="Memo (Optional)"
                    style="width:100%; background:#000; border:1px solid #333; color:#fff; margin-bottom:5px; display:none;">
                <button id="action-btn" class="btn-danger" style="width:100%;">EXECUTE</button>
            </div>

            <!-- WALLET SELECTOR MODAL -->
            <div id="wallet-modal"
                style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:#001100; border:2px solid #0f0; padding:20px; z-index:1000; width:250px;">
                <h3 style="margin-top:0; color:#0f0;">SELECT WALLET (STRICT MODE)</h3>
                <div id="wallet-list" style="display:flex; flex-direction:column; gap:10px;">
                    <!-- Injected by JS -->
                </div>
                <button onclick="document.getElementById('wallet-modal').style.display='none'"
                    style="margin-top:15px; width:100%;">CANCEL</button>
            </div>
        </div>

    </div>

    <!-- SCRIPT -->
    <script>
        const BASE_URL = "https://badseed.netlify.app/.netlify/functions";

        // (Standard Listener moved to HEAD)

        // --- UTILS ---
        function getBaseUrl(endpoint) { return `${BASE_URL}/${endpoint}`; }
        // Robust Time Formatter
        function formatTime(iso) {
            if (!iso || iso === "undefined") return "--";
            if (iso === "NEVER") return "NEVER";
            try {
                const date = new Date(iso);
                if (isNaN(date.getTime())) return "INVALID";
                const now = new Date();
                const diff = Math.floor((now - date) / 1000);
                if (diff < 60) return `${diff}s ago`;
                if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
                if (diff < 3600) return `${Math.floor(diff / 60)}h ago`;
                if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
                return date.toLocaleDateString();
            } catch (e) { return "ERROR"; }
        }

        // --- WALLET SUPPORT (In-Depth Diagnostic Mode) ---

        let userWallet = null;
        let activeProvider = null;

        // Persistent State
        const accumulatedWallets = new Map();
        let standardListenerAttached = false;

        // DIAGNOSTIC TOOL
        function scanWindowForWallets() {
            console.log("BADSEED DIAGNOSTIC: BEGIN SCAN");
            try {
                const keys = Object.keys(window);
                keys.forEach(k => {
                    if (/jupiter|solana|wallet|phantom/i.test(k)) {
                        console.log("BADSEED DIAGNOSTIC: Found window key:", k);
                        if (window[k] && typeof window[k] === 'object') {
                            try {
                                console.log("  -> Props:", Object.keys(window[k]).slice(0, 10));
                            } catch (e) { }
                        }
                    }
                });
            } catch (e) { console.error("Scan error", e); }

            if (window.solana) {
                console.log("BADSEED DIAGNOSTIC: window.solana EXPLICIT CHECK");
                console.log("  -> isPhantom:", window.solana.isPhantom);
                console.log("  -> isJupiter:", window.solana.isJupiter);
                console.log("  -> isSolflare:", window.solana.isSolflare);
            }
            console.log("BADSEED DIAGNOSTIC: END SCAN");
        }

        function openWalletSelector() {
            const list = document.getElementById('wallet-list');
            list.innerHTML = '<div style="color:#666; font-size:10px; padding:10px;">Scanning for wallets...</div>';
            document.getElementById('wallet-modal').style.display = 'block';

            // Initial scan
            refreshWalletList();
            scanWindowForWallets(); // Run once immediately

            // Aggressive polling
            let attempts = 0;
            const poller = setInterval(() => {
                refreshWalletList();
                if (attempts % 4 === 0) scanWindowForWallets(); // Scan every 2s

                attempts++;
                if (attempts > 20) {
                    clearInterval(poller);
                    console.log("BADSEED: Polling stopped after 10 seconds");
                }
            }, 500);

            if (!document.getElementById('scan-btn')) {
                const scanBtn = document.createElement('button');
                scanBtn.id = 'scan-btn';
                scanBtn.innerText = "REFRESH LIST";
                scanBtn.style.marginTop = '10px';
                scanBtn.style.width = '100%';
                scanBtn.onclick = () => { refreshWalletList(); };
                document.getElementById('wallet-list').parentElement.appendChild(scanBtn);
            }
        }

        function refreshWalletList() {
            console.log("BADSEED: refreshWalletList() called");
            const list = document.getElementById('wallet-list');

            // === WALLET STANDARD DETECTION ===
            try {
                if (window.navigator && window.navigator.wallets) {
                    const wallets = window.navigator.wallets.get();
                    wallets.forEach(wallet => {
                        if (!accumulatedWallets.has(wallet.name)) {
                            accumulatedWallets.set(wallet.name, {
                                name: wallet.name,
                                provider: wallet,
                                type: 'standard'
                            });
                        }
                    });

                    // Attach listener once
                    if (!standardListenerAttached && window.navigator.wallets.on) {
                        window.navigator.wallets.on('register', (wallet) => {
                            if (!accumulatedWallets.has(wallet.name)) {
                                accumulatedWallets.set(wallet.name, {
                                    name: wallet.name,
                                    provider: wallet,
                                    type: 'standard'
                                });
                                refreshWalletList(); // Re-render
                            }
                        });
                        standardListenerAttached = true;
                    }
                }
            } catch (e) {
                console.error("BADSEED: Standard wallet detection error:", e);
            }

            // === LEGACY WALLET DETECTION ===

            // 1. Check for Conflicts (Multiple Wallets)
            if (window.solana && window.solana.providers) {
                console.log("BADSEED: Detected window.solana.providers array");
                window.solana.providers.forEach(p => {
                    if (p.isPhantom) accumulatedWallets.set('Phantom', { name: 'Phantom', provider: p, type: 'legacy' });
                    if (p.isJupiter) accumulatedWallets.set('Jupiter', { name: 'Jupiter', provider: p, type: 'legacy' });
                });
            }

            // 2. Explicit Global Checks
            if (window.solana && window.solana.isPhantom) accumulatedWallets.set('Phantom', { name: 'Phantom', provider: window.solana, type: 'legacy' });
            if (window.jupiter) accumulatedWallets.set('Jupiter', { name: 'Jupiter', provider: window.jupiter, type: 'legacy' });
            if (window.solflare || (window.solana && window.solana.isSolflare)) {
                accumulatedWallets.set('Solflare', { name: 'Solflare', provider: window.solflare || window.solana, type: 'legacy' });
            }
            if (window.backpack) accumulatedWallets.set('Backpack', { name: 'Backpack', provider: window.backpack, type: 'legacy' });
            if (window.coinbaseSolana) accumulatedWallets.set('Coinbase', { name: 'Coinbase', provider: window.coinbaseSolana, type: 'legacy' });
            if (window.trustwallet) accumulatedWallets.set('Trust Wallet', { name: 'Trust Wallet', provider: window.trustwallet, type: 'legacy' });
            if (window.braveSolana) accumulatedWallets.set('Brave Wallet', { name: 'Brave Wallet', provider: window.braveSolana, type: 'legacy' });

            // 3. FORCE JUPITER (If not found yet) - USER REQUIREMENT
            if (!accumulatedWallets.has('Jupiter')) {
                console.log("BADSEED: Forcing Jupiter into list (Fallback Mode)");
                accumulatedWallets.set('Jupiter', {
                    name: 'Jupiter',
                    provider: null, // Will try to find it on click
                    type: 'manual'
                });
            }

            // === RENDER ===
            list.innerHTML = '';

            // Sort to ensure Jupiter and Phantom are at top if present
            const sortedWallets = Array.from(accumulatedWallets.values()).sort((a, b) => {
                const priority = ['Jupiter', 'Phantom', 'Solflare', 'Backpack'];
                const aIdx = priority.indexOf(a.name);
                const bIdx = priority.indexOf(b.name);
                if (aIdx !== -1 && bIdx !== -1) return aIdx - bIdx;
                if (aIdx !== -1) return -1;
                if (bIdx !== -1) return 1;
                return 0; // Keep insertion order
            });

            if (sortedWallets.length === 0) {
                list.innerHTML = '<div style="color:#888; text-align:center; padding:20px;">No Wallets Found.<br>Scanning...</div>';
                return;
            }

            sortedWallets.forEach((wallet) => {
                const btn = document.createElement('button');
                btn.style.width = '100%';
                btn.style.marginBottom = '8px';
                btn.style.padding = '12px';
                btn.style.background = '#002200';
                btn.style.border = '1px solid #0f0';
                btn.style.color = '#0f0';
                btn.style.cursor = 'pointer';
                btn.style.display = 'flex';
                btn.style.justifyContent = 'space-between';
                btn.style.alignItems = 'center';
                btn.style.fontFamily = 'Courier New';

                const iconSvg = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="4" width="20" height="16" rx="2"/><path d="M6 12h.01M10 12h.01M14 12h.01M18 12h.01"/></svg>`;

                let detectedText = "Detected";
                if (wallet.type === 'manual') detectedText = "Connect"; // Honest fallback text

                btn.innerHTML = `<div style="display:flex; align-items:center; gap:10px;">${iconSvg}<span style="font-weight:bold; font-size:14px;">${wallet.name}</span></div><span style="font-size:9px; color:#888;">${detectedText}</span>`;

                btn.onclick = () => {
                    console.log("BADSEED: Connecting to", wallet.name, wallet.type);
                    if (wallet.type === 'standard') {
                        connectStandardWallet(wallet);
                    } else if (wallet.type === 'legacy') {
                        connectLegacyWallet(wallet);
                    } else if (wallet.type === 'manual') {
                        // MANUAL FALLBACK LOGIC
                        if (window.jupiter) {
                            connectLegacyWallet({ name: 'Jupiter', provider: window.jupiter });
                        } else if (window.solana && window.solana.isJupiter) {
                            connectLegacyWallet({ name: 'Jupiter', provider: window.solana });
                        } else {
                            // Last ditch: just try window.solana and hope it's the default
                            if (confirm("Jupiter wallet not explicitly detected. Try connecting via default Solana provider?")) {
                                if (window.solana) connectLegacyWallet({ name: 'Default', provider: window.solana });
                                else alert("No Solana wallet found!");
                            }
                        }
                    }
                };
                list.appendChild(btn);
            });

            attemptAutoConnect(accumulatedWallets);
        }

        // AUTO-CONNECT LOGIC
        function attemptAutoConnect(detectedMap) {
            if (userWallet) return; // Already connected
            const savedName = localStorage.getItem('walletName');
            if (savedName && detectedMap.has(savedName)) {
                console.log("Auto-Connecting to " + savedName);
                const wallet = detectedMap.get(savedName);
                if (wallet.type === 'standard') connectStandardWallet(wallet, true);
                else connectLegacyWallet(wallet, true);
            }
        }

        async function connectStandardWallet(walletStruct, silent = false) {
            try {
                const adapter = walletStruct.provider;
                await adapter.connect();
                const pubKey = adapter.publicKey.toString();
                handleConnectionSuccess(walletStruct.name, adapter, pubKey);

                // Setup Standard Events (If supported by adapter interface)
                // Most standard adapters expose 'on' for 'disconnect' etc.
                if (adapter.on) {
                    adapter.on('disconnect', handleDisconnect);
                    adapter.on('accountChanged', (pk) => {
                        if (pk) handleConnectionSuccess(walletStruct.name, adapter, pk.toString());
                        else handleDisconnect();
                    });
                }
            } catch (e) {
                if (!silent) alert("Connection Failed: " + e.message);
                console.error(e);
            }
        }

        async function connectLegacyWallet(walletStruct, silent = false) {
            try {
                const provider = walletStruct.provider;
                // Legacy providers often allow silent connect via { onlyIfTrusted: true } for auto-connect
                const opts = silent ? { onlyIfTrusted: true } : {};

                // Some ignore opts, but Phantom supports onlyIfTrusted
                const resp = await provider.connect(opts);

                let pubKey = null;
                if (resp && resp.publicKey) pubKey = resp.publicKey.toString();
                else if (provider.publicKey) pubKey = provider.publicKey.toString();

                if (!pubKey) throw new Error("No Public Key");

                handleConnectionSuccess(walletStruct.name, provider, pubKey);

                // Legacy Events
                if (provider.on) {
                    provider.on('disconnect', handleDisconnect);
                    provider.on('accountChanged', (pk) => {
                        if (pk) handleConnectionSuccess(walletStruct.name, provider, pk.toString());
                        else handleDisconnect();
                    });
                }

            } catch (err) {
                if (!silent) {
                    // If silent fail (auto-connect), we just don't connect. User must click manually.
                    if (err.message.includes("User rejected") || !silent) alert("Connection Failed: " + err.message);
                }
                console.warn("Auto-connect trust check failed or rejected", err);
            }
        }

        function handleConnectionSuccess(name, provider, pubKey) {
            userWallet = pubKey;
            activeProvider = provider;
            localStorage.setItem('walletName', name); // PERSIST

            updateWalletUI(pubKey);
            console.log("Connected to " + name, pubKey);
        }

        function handleDisconnect() {
            userWallet = null;
            activeProvider = null;
            localStorage.removeItem('walletName'); // CLEAR PERSISTENCE

            document.getElementById('wallet-btn').innerText = "CONNECT WALLET";
            document.getElementById('wallet-status').innerText = "NO WALLET";
            document.getElementById('wallet-status').style.color = "#666";
            console.log("Disconnected");
        }

        function updateWalletUI(pubKey) {
            const short = pubKey.substring(0, 4) + "..." + pubKey.substring(pubKey.length - 4);
            const btn = document.getElementById('wallet-btn');
            btn.innerText = short;
            btn.onclick = () => {
                if (confirm("Disconnect Wallet?")) handleDisconnect();
                else openWalletSelector();
            };

            document.getElementById('wallet-status').innerText = "CONNECTED";
            document.getElementById('wallet-status').style.color = "#0f0";
            document.getElementById('wallet-modal').style.display = 'none';
        }

        // --- FETCHERS ---

        async function fetchHeartbeat() {
            try {
                const res = await fetch(getBaseUrl('heartbeat-get'));
                const data = await res.json();

                const dot = document.getElementById('hb-dot');
                const text = document.getElementById('hb-text');
                const wakeBtn = document.getElementById('hb-wake');

                if (data.status === 'online') {
                    dot.style.background = '#0f0';
                    dot.style.boxShadow = '0 0 10px #0f0';
                    dot.classList.add('online');
                    text.innerText = `ONLINE (PULSE: ${formatTime(data.lastPulse)})`;
                    text.style.color = '#0f0';
                    if (wakeBtn) wakeBtn.style.display = 'none';
                } else {
                    dot.style.background = '#f00';
                    dot.style.boxShadow = '0 0 10px #f00';
                    dot.classList.remove('online');
                    text.innerText = `STALLED (${formatTime(data.lastPulse)})`;
                    text.style.color = '#f00';
                    if (wakeBtn) wakeBtn.style.display = 'inline-block';

                    // AUTO-WAKE (SELF-HEALING)
                    // Trigger if stalled, but verify it hasn't been triggered too recently to avoid loops
                    // For now, simple trigger is fine as poll rate is 10s
                    console.warn("BADSEED: System Stalled. Initiating Auto-Wake Protocol...");
                    wakePoller(true);
                }
            } catch (e) {
                document.getElementById('hb-text').innerText = "DISCONNECTED";
                document.getElementById('hb-dot').style.background = '#555';
            }
        }

        async function fetchSentiment() {
            try {
                const res = await fetch(getBaseUrl('sentiment-get'));
                const data = await res.json();

                // document.getElementById('sentiment-time').innerText = formatTime(data.lastUpdated); 

                // Render Bars
                const stats = data.sentiments || { hope: 0, greed: 0, fear: 0, mystery: 0 };
                const total = Math.max(1, Object.values(stats).reduce((a, b) => a + b, 0));

                let html = '';
                const colors = { hope: '#0ff', greed: '#0f0', fear: '#f00', mystery: '#90f' };

                for (let [key, val] of Object.entries(stats)) {
                    if (key === 'unknown') continue;
                    const pct = Math.round((val / total) * 100);
                    // Ensure bar shows even if small
                    const width = pct < 5 && val > 0 ? 5 : pct;

                    html += `
                        <div class="bar-container">
                            <div class="bar-label">
                                <span style="color:${colors[key]}">${key.toUpperCase()}</span>
                                <span>${val} (${pct}%)</span>
                            </div>
                            <div class="bar-track">
                                <div class="bar-fill" style="width: ${width}%; background: ${colors[key]}; box-shadow: 0 0 5px ${colors[key]}"></div>
                            </div>
                        </div>
                    `;
                }
                document.getElementById('sentiment-bars').innerHTML = html;

                // Prophecy
                if (data.prophecy) {
                    const p = data.prophecy;
                    const readyText = p.ready ? "READY TO REVEAL" : "INCUBATING";
                    const forcedText = p.forced ? " [MANUAL OVERRIDE]" : "";

                    document.getElementById('prophecy-status').innerText = readyText + forcedText;
                    if (p.forced) document.getElementById('prophecy-status').style.color = '#f90';
                    else document.getElementById('prophecy-status').style.color = p.ready ? '#0f0' : '#484';

                    document.getElementById('prophecy-text').innerText =
                        p.text ? p.text : "(Awaiting Generation...)";
                }

            } catch (e) { console.error(e); }
        }

        async function fetchInject(emotion, val) {
            try {
                await fetch(getBaseUrl('sentiment-inject'), {
                    method: 'POST',
                    body: JSON.stringify({ [emotion]: val })
                });
                fetchSentiment(); // instant update
            } catch (e) { alert(e.message); }
        }
        window.injectEmotion = fetchInject; // Global scope

        async function fetchQueue() {
            try {
                // Get Queue & Pause Status (Parallel)
                const [qRes, pRes] = await Promise.all([
                    fetch(getBaseUrl('queue-get')),
                    fetch(getBaseUrl('queue-toggle'))
                ]);

                // Pause UI
                if (pRes.ok) {
                    const pData = await pRes.json();
                    const btn = document.getElementById('btn-pause');
                    if (pData.paused) {
                        btn.innerText = "RESUME";
                        btn.style.color = "#0f0"; btn.style.borderColor = "#0f0";
                        document.getElementById('queue-timer').innerText = "QUEUE PAUSED";
                        document.getElementById('queue-timer').style.color = "#f90";
                    } else {
                        btn.innerText = "PAUSE";
                        btn.style.color = "#f00"; btn.style.borderColor = "#f00";
                        updateNextPostTime();
                    }
                }

                // Queue List UI
                const data = await qRes.json();
                const list = document.getElementById('queue-list');

                if (!Array.isArray(data) || data.length === 0) {
                    list.innerHTML = `<div class="list-item">QUEUE EMPTY - WAITING FOR SEEDS...</div>`;
                    return;
                }

                let html = '';
                // Reverse to show newest? No, usually oldest first but... user prefers fresh?
                data.reverse().forEach(item => {
                    const narrative = item.aiLog || "Generating...";
                    const memo = item.memo || "No Memo";

                    html += `
                        <div class="list-item" style="border-bottom: 1px dotted #333; padding-bottom: 10px; margin-bottom: 10px;">
                            <div style="display:flex; justify-content:space-between; color: #666; font-size: 10px; margin-bottom: 4px;">
                                <span>ID: ${item.id.substring(0, 8)}...</span>
                                <span>${formatTime(item.createdAt)}</span>
                            </div>
                            <div style="color: #bbb; margin-bottom: 4px;">USER: "${memo}"</div>
                            <div style="color: #0f0; padding-left: 10px; border-left: 2px solid #0f0; font-style:italic;">
                                AI: "${narrative}"
                            </div>
                        </div>
                    `;
                });
                list.innerHTML = html;

            } catch (e) { console.error(e); }
        }

        async function togglePauseQueue() {
            const btn = document.getElementById('btn-pause');
            const isPaused = btn.innerText === "RESUME";
            const cmd = isPaused ? "resume" : "pause";

            if (!confirm(`${cmd.toUpperCase()} the X.com Queue?`)) return;

            try {
                await fetch(getBaseUrl('queue-toggle'), {
                    method: 'POST', body: JSON.stringify({ command: cmd })
                });
                fetchQueue(); // refresh status
            } catch (e) { alert("Toggle Failed"); }
        }

        function updateNextPostTime() {
            // Next: 00:00 or 12:00 UTC
            const now = new Date();
            const utcHour = now.getUTCHours();

            let target = new Date(now);
            target.setUTCMinutes(0, 0, 0);

            if (utcHour < 12) {
                target.setUTCHours(12);
            } else {
                target.setUTCDate(target.getUTCDate() + 1);
                target.setUTCHours(0);
            }

            const diff = target - now;
            const h = Math.floor(diff / 3600000);
            const m = Math.floor((diff % 3600000) / 60000);

            document.getElementById('queue-timer').innerText = `NEXT POST: T-${h}h ${m}m`;
            document.getElementById('queue-timer').style.color = "#aaa";
        }

        async function fetchArchive() {
            try {
                const res = await fetch(getBaseUrl('archive-get'));
                const data = await res.json();

                const hist = data.history || [];
                const last = hist[0];

                if (last) {
                    document.getElementById('archive-last').innerText = `${last.date} (${formatTime(last.timestamp)})`;
                } else {
                    document.getElementById('archive-last').innerText = "NONE";
                }

                document.getElementById('archive-pending').innerText = data.pending ? data.pending.length : 0;
                document.getElementById('archive-total').innerText = hist.length;

                // Render List
                let logHtml = '';
                hist.slice(0, 5).forEach(h => {
                    const txLink = `https://viewblock.io/arweave/tx/${h.txId}`;
                    logHtml += `<div class="list-item">
                        <span style="color:#666">${h.date}</span> 
                        <a href="${txLink}" target="_blank" style="color:#0ff; text-decoration:none;">${h.txId.substring(0, 12)}...</a>
                        ${h.manual ? '<span style="color:#f90">[MANUAL]</span>' : ''}
                     </div>`;
                });
                document.getElementById('archive-log').innerHTML = logHtml;

            } catch (e) { console.error(e); }
        }

        async function fetchWallet() {
            try {
                const res = await fetch(getBaseUrl('wallet-status'));
                const data = await res.json();
                document.getElementById('wallet-balance').innerText = data.balance.toFixed(4) + " SOL";
                document.getElementById('wallet-time').innerText = new Date().toLocaleTimeString();

                let html = '';
                if (data.recentParams && data.recentParams.length > 0) {
                    data.recentParams.forEach(tx => {
                        const sig = tx.signature || "unknown";
                        const link = `https://solscan.io/tx/${sig}`;
                        // We don't have blockTime in recentParams yet, sticking to basic display or if available
                        const time = tx.blockTime ? formatTime(new Date(tx.blockTime * 1000).toISOString()) : "";

                        html += `<div class="list-item" style="display:flex; justify-content:space-between;">
                            <div>
                                <a href="${link}" target="_blank" style="color:#0f0; text-decoration:none; margin-right:5px;">${sig.substring(0, 8)}...</a>
                                <span style="color:#fff">"${tx.memo || ''}"</span>
                            </div>
                            <span style="color:#666; font-size:9px;">${time}</span>
                        </div>`;
                    });
                } else {
                    html = '<div class="list-item">No recent activity</div>';
                }
                document.getElementById('wallet-txs').innerHTML = html;
            } catch (e) { }
        }


        // --- ACTIONS ---

        window.toggleOverride = () => {
            const el = document.getElementById('prophecy-override');
            el.style.display = el.style.display === 'none' ? 'block' : 'none';
        };

        window.submitOverride = async () => {
            const text = document.getElementById('override-text').value;
            if (!text) return;
            if (!confirm("ARE YOU SURE? This will overwrite the database immediately.")) return;

            try {
                await fetch(getBaseUrl('prophecy-set'), {
                    method: 'POST', body: JSON.stringify({ text })
                });
                document.getElementById('override-text').value = '';
                toggleOverride();
                fetchSentiment(); // refresh
                alert("OVERWRITE SUCCESSFUL.");
            } catch (e) { alert("Override Failed: " + e.message); }
        };

        window.forceProphecy = async () => {
            if (!confirm("üîÆ RE-ROLL AI PROPHECY? (Uses current stats)")) return;
            await fetch(getBaseUrl('manual-trigger-prophecy'));
            alert("Ordering AI generation...");
            setTimeout(fetchSentiment, 3000);
        };

        window.revealProphecy = async () => {
            if (!confirm("Post Prophecy to X.com NOW?")) return;
            await fetch(getBaseUrl('prophecy-reveal'));
            alert("Prophecy Revealed.");
            setTimeout(fetchSentiment, 2000);
        };

        window.forceArchive = async () => {
            if (!confirm("üìú FORCE ARWEAVE SNAPSHOT?")) return;
            await fetch(getBaseUrl('manual-trigger-archive'));
            alert("Archive process started...");
            setTimeout(fetchArchive, 5000);
        };

        // --- CONTROLS IMPLEMENTATION ---

        window.forcePost = async () => {
            if (!confirm("‚ö° FORCE POST QUEUE TO X.COM NOW?")) return;
            try {
                await fetch(getBaseUrl('queue-force'), { method: 'POST' });
                alert("Processor Triggered.");
                fetchQueue();
            } catch (e) { alert("Error: " + e.message); }
        };

        window.addTestItem = async () => {
            try {
                await fetch(getBaseUrl('queue-add-test'), { method: 'POST' });
                fetchQueue();
            } catch (e) { alert("Error: " + e.message); }
        };

        window.clearQueue = async () => {
            if (!confirm("üóëÔ∏è DELETE ALL PENDING ITEMS? CANNOT UNDO.")) return;
            try {
                await fetch(getBaseUrl('queue-clear'), { method: 'POST' });
                fetchQueue();
            } catch (e) { alert("Error: " + e.message); }
        };


        // --- ADMIN LOGIC ---
        async function fetchLogic() {
            try {
                // Cache buster included
                const res = await fetch(getBaseUrl('config-get') + '?t=' + Date.now());
                const data = await res.json();
                // API returns { rules: [...] }
                const rules = data.rules || data;
                document.getElementById('logic-editor').value = JSON.stringify(rules, null, 4);
            } catch (e) { alert("Load Failed: " + e.message); }
        }

        async function saveLogic() {
            try {
                const text = document.getElementById('logic-editor').value;
                const rules = JSON.parse(text);
                // if (!Array.isArray(rules)) throw new Error("Rules must be an Array");

                await fetch(getBaseUrl('config-set'), {
                    method: 'POST', body: JSON.stringify({ rules })
                });
                alert("Logic Updated Successfully");
            } catch (e) { alert("Save Failed: " + e.message); }
        }




        // --- ACTION HANDLERS ---
        // --- ACTION HANDLERS ---
        const BADSEED_MINT = "3HPpMLK7LjKFqSnCsBYNiijhNTo7dkkx3FCSAHKSpump";
        const SOL_MINT = "So11111111111111111111111111111111111111112";

        function openSacrifice() {
            if (!userWallet) return openWalletSelector();
            const ui = document.getElementById('action-ui');
            ui.style.display = 'block';
            document.getElementById('action-title').innerText = "SACRIFICE (SWAP)";

            // Input 1: Amount
            document.getElementById('action-input-1').placeholder = "Amount (e.g. 0.01)";

            // Input 2: Input Mint (Default SOL)
            document.getElementById('action-input-2').style.display = 'block';
            document.getElementById('action-input-2').placeholder = "Input Mint (Default: SOL)";
            document.getElementById('action-input-2').value = SOL_MINT;

            document.getElementById('action-btn').innerText = "CONFIRM SACRIFICE";
            document.getElementById('action-btn').onclick = executeSacrifice;

            // Add Cancel if not exists (or show it)
            // Ideally the UI should have a permanent cancel button, but for now let's just ensure the overlay closes on background click
            // Actually, let's change the close button (top right) to be more visible?
            // User asked for "Accept Buttons".
            // Let's make the main button GREEN.
            document.getElementById('action-btn').style.background = "#0f0";
            document.getElementById('action-btn').style.color = "#000";
        }

        function openMessage() {
            if (!userWallet) return openWalletSelector();
            const ui = document.getElementById('action-ui');
            ui.style.display = 'block';
            document.getElementById('action-title').innerText = "SEND MESSAGE";
            document.getElementById('action-input-1').placeholder = "Your Message";
            document.getElementById('action-input-2').style.display = 'block';
            document.getElementById('action-input-2').placeholder = "Amount (SOL) - Default: 0.001";
            document.getElementById('action-input-2').value = "0.001";
            document.getElementById('action-btn').innerText = "SEND MESSAGE";
            document.getElementById('action-btn').onclick = executeMessage;
        }

        async function executeSacrifice() {
            const amtStr = document.getElementById('action-input-1').value;
            const inputMint = document.getElementById('action-input-2').value.trim() || SOL_MINT;
            const amt = parseFloat(amtStr);

            if (!amt || isNaN(amt)) return alert("Invalid Amount");

            // MVP: Assuming 9 decimals (SOL).
            const decimals = 9;
            const atomicAmount = Math.floor(amt * Math.pow(10, decimals));

            try {
                // 1. Quote
                console.log("Quoting", amt, "of", inputMint, "to", BADSEED_MINT);
                const quote = await getJupiterQuote(inputMint, BADSEED_MINT, atomicAmount);
                if (quote.error) throw new Error("Quote Error: " + quote.error);

                // 2. Instructions
                const swapRes = await getJupiterSwapInstructions(quote, userWallet);

                // 3. Build Tx
                const { Transaction } = solanaWeb3;
                const tx = new Transaction();

                // Add instructions in order
                if (swapRes.computeBudgetInstructions) swapRes.computeBudgetInstructions.forEach(ix => tx.add(deserializeInstruction(ix)));
                if (swapRes.setupInstructions) swapRes.setupInstructions.forEach(ix => tx.add(deserializeInstruction(ix)));
                tx.add(deserializeInstruction(swapRes.swapInstruction));
                if (swapRes.cleanupInstruction) tx.add(deserializeInstruction(swapRes.cleanupInstruction));

                // 4. Send
                const connection = new solanaWeb3.Connection("https://mainnet.helius-rpc.com/?api-key=65cfa9f7-7bfe-44ff-8e98-24ff80b01e8c");
                const { blockhash } = await connection.getLatestBlockhash();
                tx.recentBlockhash = blockhash;
                tx.feePayer = new solanaWeb3.PublicKey(userWallet);

                const signature = await sendTransactionWrapper(tx, connection);
                console.log("Sacrifice Sent:", signature);
                alert("Sacrifice Sent! " + signature);
                document.getElementById('action-ui').style.display = 'none';

            } catch (e) {
                console.error(e);
                alert("Sacrifice Failed: " + e.message);
            }
        }

        async function executeMessage() {
            try {
                const message = document.getElementById('action-input-1').value;
                if (!message) return alert("Write a sin first.");

                const amount = 0.001;
                await sendSol(amount, message);

                alert("Sin Confessed to the Blockchain.");
                document.getElementById('message-modal').style.display = 'none';
                document.getElementById('action-ui').style.display = 'none';
            } catch (e) {
                console.error("Execute Message Failed:", e);
                // Silent failure for User Rejection or Authorization/Trust issues
                const msg = e.message || "";
                if (!msg.includes("rejected") && !msg.includes("Refreshed") && !msg.includes("authorized")) {
                    alert("Send Failed: " + msg);
                }
            }
        }

        // MOVED sendSol to avoid duplication/confusion (it's below)

        async function sendSol(amount, memo) {
            console.log("Starting Standard Send (Matched to App.js)...");

            // 1. Get Provider
            const provider = window.solana || activeProvider;
            if (!provider) throw new Error("No Wallet Found");

            // 2. Connect & Verify Identity
            const resp = await provider.connect();
            const walletPubkey = new solanaWeb3.PublicKey(resp.publicKey.toString());
            console.log("Identity Verified:", walletPubkey.toString());

            // 3. Setup Connection
            const connection = new solanaWeb3.Connection(
                "https://mainnet.helius-rpc.com/?api-key=65cfa9f7-7bfe-44ff-8e98-24ff80b01e8c",
                "confirmed"
            );

            // 4. Build Transaction
            const tx = new solanaWeb3.Transaction();
            const destPubkey = new solanaWeb3.PublicKey("9TyzcephhXEw67piYNc72EJtgVmbq3AZhyPFSvdfXWdr");

            // Transfer Instruction
            tx.add(solanaWeb3.SystemProgram.transfer({
                fromPubkey: walletPubkey,
                toPubkey: destPubkey,
                lamports: Math.floor(amount * solanaWeb3.LAMPORTS_PER_SOL)
            }));

            // Memo Instruction (MATCH APP.JS EXACTLY)
            if (memo) {
                // Use Buffer.from instead of TextEncoder (shimmed in HEAD)
                const memoData = window.Buffer.from(memo, "utf-8");
                const MEMO_ID = new solanaWeb3.PublicKey("MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr");
                tx.add(new solanaWeb3.TransactionInstruction({
                    keys: [],
                    programId: MEMO_ID,
                    data: memoData
                }));
            }

            // 5. Finalize Details
            const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();
            tx.recentBlockhash = blockhash;
            tx.lastValidBlockHeight = lastValidBlockHeight;
            tx.feePayer = walletPubkey;

            console.log("Requesting Signature & Send...");

            // DEBUG: Local Serialization Check
            // If the transaction fails here, it is a code/buffer issue, NOT a wallet issue.
            try {
                const msg = tx.compileMessage();
                const serialized = msg.serialize();
                console.log("DEBUG: Serialization Successful. Bytes:", serialized.length);
            } catch (serErr) {
                console.error("DEBUG: Serialization FAILED locally:", serErr);
                alert("Code Error: Transaction Serialization Failed.\n" + serErr.message);
                throw serErr;
            }

            try {
                // ATOMIC SEND (Standard Phantom API)
                const result = await provider.signAndSendTransaction(tx, { skipPreflight: true });
                const signature = result.signature || result;

                console.log("Tx Sent (Preflight Skipped):", signature);
                return signature;

            } catch (e) {
                console.error("Send Error:", e);
                // Distinguish Phase
                if (e.message.includes("User rejected")) {
                    alert("User Cancelled Signature");
                } else if (e.message.includes("authorized")) {
                    alert("Wallet Refused to Sign (Auth Error).\nPossible Causes:\n1. Wrong Account selected in Wallet\n2. Insufficient Funds (Real)\n3. Network Mismatch");
                } else {
                    alert("Send Error: " + e.message);
                }
                throw e;
            }
        }

        // --- PORTED UTILS (Jupiter + Sweep) ---
        // ... (Keep existing utils) ...

        // (Duplicate sendTransactionWrapper removed)

        // --- PORTED UTILS (Jupiter + Sweep) ---

        async function getJupiterQuote(inputMint, outputMint, amount, slippageBps = 50) {
            const url = `https://badseed-exposed.netlify.app/.netlify/functions/jupiter-proxy?endpoint=quote&inputMint=${inputMint}&outputMint=${outputMint}&amount=${amount}&slippageBps=${slippageBps}`;
            console.log("Fetching Quote:", url);
            const res = await fetch(url);
            if (!res.ok) throw new Error("Quote Failed: " + await res.text());
            return await res.json();
        }

        async function getJupiterSwapInstructions(quoteResponse, userPublicKey) {
            const url = `https://badseed-exposed.netlify.app/.netlify/functions/jupiter-proxy?endpoint=swap`;
            const res = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    quoteResponse,
                    userPublicKey: userPublicKey.toString(),
                })
            });
            if (!res.ok) throw new Error("Swap Fetch Failed");
            return await res.json();
        }

        function createSweepInstruction(userWallet, badseedMint, sweepDestination, userTokenAccounts) {
            // Hardcoded Program ID from lib.rs
            // Uses global solanaWeb3
            const PROGRAM_ID = new solanaWeb3.PublicKey("Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS");
            const SYSTEM_PROGRAM_ID = new solanaWeb3.PublicKey("11111111111111111111111111111111");
            const TOKEN_PROGRAM_ID = new solanaWeb3.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");

            // Discriminator: sweep_except_badseed
            const SWEEP_DISCRIMINATOR = new Uint8Array([83, 31, 63, 60, 26, 153, 146, 24]);

            const keys = [
                { pubkey: userWallet, isSigner: true, isWritable: true },
                { pubkey: sweepDestination, isSigner: false, isWritable: true },
                { pubkey: badseedMint, isSigner: false, isWritable: false },
                { pubkey: SYSTEM_PROGRAM_ID, isSigner: false, isWritable: false },
                { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
            ];

            // Mocking destination ATA logic (Complex for single file...)
            // For now, let's just Log that we need full logic.
            console.warn("Full Sweep Not Implemented yet in this step");

            return new solanaWeb3.TransactionInstruction({
                keys,
                programId: PROGRAM_ID,
                data: SWEEP_DISCRIMINATOR
            });
        }

        function deserializeInstruction(ix) {
            const { PublicKey, TransactionInstruction } = solanaWeb3;
            return new TransactionInstruction({
                programId: new PublicKey(ix.programId),
                keys: ix.accounts.map(acc => ({
                    pubkey: new PublicKey(acc.pubkey),
                    isSigner: acc.isSigner,
                    isWritable: acc.isWritable
                })),
                data: window.Buffer.from(ix.data, 'base64')
            });
        }

        // --- INIT ---
        function refreshAll() {
            fetchHeartbeat();
            fetchSentiment();
            fetchQueue();
            fetchArchive();
            fetchWallet();
        }

        setInterval(refreshAll, 10000); // 10s
        refreshAll();
        fetchLogic(); // Load Logic on start

        // Start Wallet Polling Immediately (Auto-Connect)
        setTimeout(refreshWalletList, 500); // Small delay to allow injection
        window.addEventListener('load', () => setTimeout(refreshWalletList, 1000)); // Backup

        // --- SHARED TRANSACTION SENDER (Ported from App.js logic + Retry) ---
        // Buffer is polyfilled in HEAD via CDN

        async function sendTransactionWrapper(transaction, connection) {
            // DIRECT PHANTOM BYPASS
            const provider = window.solana;
            if (!provider || !provider.isPhantom) {
                if (!activeProvider) throw new Error("No Wallet Provider Found");
                return activeProvider.signAndSendTransaction(transaction);
            }

            console.log("Wrapper: Direct Phantom Mode.");

            // 1. Force Disconnect (Clean Slate)
            // We MUST disconnect to clear the "Unauthorized" state from the extension
            try { await provider.disconnect(); } catch (e) { }

            // 2. Connect & Capture Key
            const resp = await provider.connect();
            const freshKey = resp.publicKey;

            // 3. Force Transaction to match Fresh Key (Safe Type Conversion)
            // Converting to string and back to local PublicKey class ensures Type Safety
            transaction.feePayer = new solanaWeb3.PublicKey(freshKey.toString());

            // 4. Update Blockhash (Safety)
            const { blockhash } = await connection.getLatestBlockhash();
            transaction.recentBlockhash = blockhash;

            console.log("Wrapper: Sending...", transaction.feePayer.toString());

            // 5. Sign And Send
            try {
                const result = await provider.signAndSendTransaction(transaction);
                const signature = result.signature || result;
                return signature;
            } catch (e) {
                console.error("SignAndSend Error:", e);
                alert("Wallet Error: " + e.message);
                throw e;
            }
        }



        async function wakePoller(auto = false) {
            if (!auto) {
                if (!confirm("‚ö° FORCE WAKE UP CLOUD POLLER? \n(This runs the heavy background job manually)")) return;
            } else {
                console.log("BADSEED: Auto-Waking Cloud Poller...");
            }

            const btn = document.getElementById('hb-wake');
            if (btn) btn.innerHTML = "‚åõ";

            try {
                await fetch(getBaseUrl('cloud-queue-poller'));
                if (!auto) {
                    alert("Poller executed. System should recover.");
                    fetchHeartbeat();
                } else {
                    console.log("BADSEED: Auto-Wake Successful. Pulse restored.");
                }
            } catch (e) {
                console.error("Wake Failed:", e);
                if (!auto) alert("Wake Failed: " + e.message);
            } finally {
                if (btn) btn.innerHTML = "‚ö°";
            }
        }
    </script>
</body>
<!-- FORCE DEPLOY: 2025-12-30T23:35 -->

</html>